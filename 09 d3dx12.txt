こんかいは
①d3d12の拡張バージョンの使用方法
②２体のモデル表示方法
③マイクロソフト推奨のテクスチャバッファの作り方
をやっていきます。

======================================================================================
☆まずフォルダ内のdx3dx12.hをプロジェクトに追加してください

======================================================================================
☆WinMain.hをすべて以下に置き換えてください
#pragma once
#pragma comment(lib,"dxgi.lib")
#pragma comment(lib,"d3d12.lib")
#pragma comment(lib,"dxguid.lib")  //extentionを使うにはこれが必要になる
#include<cassert>
#include<Windows.h>
#include<dxgi1_6.h>
#include"d3dx12.h"  //extentionを使うにはこれが必要になる
#include<DirectXMath.h>
using namespace DirectX;
#include"BIN_FILE12.h"  //このヘッダも作ってないと動きません
#define STB_IMAGE_IMPLEMENTATION
#include"stb_image.h"
void WaitDrawDone();
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

//ウィンドウ------------------------------------------------------------------------
LPCWSTR	WindowTitle = L"loveDX12";
const int ClientWidth = 1280;
const int ClientHeight = 720;
const int ClientPosX = (GetSystemMetrics(SM_CXSCREEN) - ClientWidth) / 2;//中央表示
const int ClientPosY = (GetSystemMetrics(SM_CYSCREEN) - ClientHeight) / 2;//中央表示
const float Aspect = static_cast<float>(ClientWidth) / ClientHeight;
#if 1 
DWORD WindowStyle = WS_OVERLAPPEDWINDOW;
#else 
DWORD WindowStyle = WS_POPUP;//Alt + F4で閉じる
#endif
HWND HWnd;
//デバイス-------------------------------------------------------------------------
ID3D12Device* Device;
//コマンド
ID3D12CommandAllocator* CommandAllocator;
ID3D12GraphicsCommandList* CommandList;
ID3D12CommandQueue* CommandQueue;
//フェンス
ID3D12Fence* Fence;
HANDLE FenceEvent;
UINT64 FenceValue;
//デバッグ
HRESULT Hr;

//リソース-----------------------------------------------------------------------
//バックバッファ
IDXGISwapChain4* SwapChain;
ID3D12Resource* BackBufs[2];
UINT BackBufIdx;
ID3D12DescriptorHeap* BackBufViewHeap;
UINT BackBufViewHeapSize;

//頂点バッファ
ID3D12Resource* PositionBuf;
D3D12_VERTEX_BUFFER_VIEW PositionBufView;
ID3D12Resource* TexcoordBuf;
D3D12_VERTEX_BUFFER_VIEW TexcoordBufView;
//頂点インデックスバッファ
ID3D12Resource* IndexBuf;
D3D12_INDEX_BUFFER_VIEW IndexBufView;

//コンスタントバッファ０構造体
struct CONST_BUF0 {
    XMMATRIX world;
    XMMATRIX view;
    XMMATRIX proj;
};
//コンスタントバッファ１構造体
struct CONST_BUF1 {
    XMFLOAT4 diffuse;
};

//モデル＿ａ------------------------
//コンスタントバッファ０＿ａ
ID3D12Resource* ConstBuf0_a;
CONST_BUF0* MapConstBuf0_a;
//コンスタントバッファ１＿ａ
ID3D12Resource* ConstBuf1_a;
CONST_BUF1* MapConstBuf1_a;
//テクスチャバッファ＿ａ
ID3D12Resource* TextureBuf_a;
//ディスクリプタヒープ＿ａ
ID3D12DescriptorHeap* CbvTbvHeap_a;// Const Buf View と Texture Buf View の Heap

//モデル＿ｂ------------------------
//コンスタントバッファ０＿ｂ
ID3D12Resource* ConstBuf0_b;
CONST_BUF0* MapConstBuf0_b;
//コンスタントバッファ１＿ｂ
ID3D12Resource* ConstBuf1_b;
CONST_BUF1* MapConstBuf1_b;
//テクスチャバッファ＿ｂ
ID3D12Resource* TextureBuf_b;
//ディスクリプタヒープ＿ｂ
ID3D12DescriptorHeap* CbvTbvHeap_b;// Const Buf View と Texture Buf View の Heap

//パイプライン--------------------------------------------------------------------
ID3D12RootSignature* RootSignature;
ID3D12PipelineState* PipelineState;
D3D12_VIEWPORT Viewport;
D3D12_RECT ScissorRect;



======================================================================================
☆WinMain.cppも全て以下に置き換えてください
#include"WinMain.h"

INT WINAPI wWinMain(_In_ HINSTANCE, _In_opt_ HINSTANCE, _In_ PWSTR, _In_ INT)
{
	//ウィンドウ
	{
		//ウィンドウクラス登録
		WNDCLASSEX windowClass = {};
		windowClass.cbSize = sizeof(WNDCLASSEX);
		windowClass.style = CS_HREDRAW | CS_VREDRAW;
		windowClass.lpfnWndProc = WndProc;
		windowClass.hInstance = GetModuleHandle(0);
		windowClass.hCursor = LoadCursor(NULL, IDC_ARROW);
		windowClass.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
		windowClass.lpszClassName = L"GAME_WINDOW";
		RegisterClassEx(&windowClass);
		//表示位置、ウィンドウの大きさ調整
		RECT windowRect = { 0, 0, ClientWidth, ClientHeight };
		AdjustWindowRect(&windowRect, WindowStyle, FALSE);
		int windowPosX = ClientPosX + windowRect.left;
		int windowPosY = ClientPosY + windowRect.top;
		int windowWidth = windowRect.right - windowRect.left;
		int windowHeight = windowRect.bottom - windowRect.top;
		//ウィンドウをつくる
		HWnd = CreateWindowEx(
			NULL,
			L"GAME_WINDOW",
			WindowTitle,
			WindowStyle,
			windowPosX,
			windowPosY,
			windowWidth,
			windowHeight,
			NULL,		//親ウィンドウなし
			NULL,		//メニューなし
			GetModuleHandle(0),
			NULL);		//複数ウィンドウなし
		//ウィンドウ表示
		ShowWindow(HWnd, SW_SHOW);
	}
	//デバイス
	{
#ifdef _DEBUG
		//デバッグバージョンではデバッグレイヤーを有効化する
		ID3D12Debug* debug;
		Hr = D3D12GetDebugInterface(IID_PPV_ARGS(&debug));
		assert(SUCCEEDED(Hr));
		debug->EnableDebugLayer();
		debug->Release();
#endif
		//デバイスをつくる(簡易バージョン)
		{
			Hr = D3D12CreateDevice(nullptr, D3D_FEATURE_LEVEL_12_0, 
				IID_PPV_ARGS(&Device));
			assert(SUCCEEDED(Hr));
		}
		//コマンド
		{
			//コマンドアロケータをつくる
			Hr = Device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT,
				IID_PPV_ARGS(&CommandAllocator));
			assert(SUCCEEDED(Hr));

			//コマンドリストをつくる
			Hr = Device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT,
				CommandAllocator, nullptr, IID_PPV_ARGS(&CommandList));
			assert(SUCCEEDED(Hr));

			//コマンドキューをつくる
			D3D12_COMMAND_QUEUE_DESC desc = {};
			desc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;		//GPUタイムアウトが有効
			desc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;		//直接コマンドキュー
			Hr = Device->CreateCommandQueue(&desc, IID_PPV_ARGS(&CommandQueue));
			assert(SUCCEEDED(Hr));
		}
		//フェンス
		{
			//GPUの処理完了をチェックするフェンスをつくる
			Hr = Device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&Fence));
			assert(SUCCEEDED(Hr));
			FenceEvent = CreateEventEx(nullptr, FALSE, FALSE, EVENT_ALL_ACCESS);
			assert(FenceEvent != nullptr);
			FenceValue = 1;
		}
	} 
	//リソース		
	{
		//スワップチェインをつくる(ここにバックバッファが含まれている)
		{
			//DXGIファクトリをつくる
			IDXGIFactory4* dxgiFactory;
			Hr = CreateDXGIFactory2(0, IID_PPV_ARGS(&dxgiFactory));
			assert(SUCCEEDED(Hr));

			//スワップチェインをつくる
			DXGI_SWAP_CHAIN_DESC1 desc = {};
			desc.BufferCount = 2; //バックバッファ2枚
			desc.Width = ClientWidth;
			desc.Height = ClientHeight;
			desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
			desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
			desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
			desc.SampleDesc.Count = 1;
			IDXGISwapChain1* swapChain;
			Hr = dxgiFactory->CreateSwapChainForHwnd(
				CommandQueue, HWnd, &desc, nullptr, nullptr, &swapChain);
			assert(SUCCEEDED(Hr));

			//IDXGISwapChain4インターフェイスをサポートしているか尋ねる
			Hr = swapChain->QueryInterface(IID_PPV_ARGS(&SwapChain));
			assert(SUCCEEDED(Hr));

			swapChain->Release();
			dxgiFactory->Release();
		}
		//バックバッファ「ビュー」の入れ物である「ディスクリプタヒープ」をつくる
		{
			D3D12_DESCRIPTOR_HEAP_DESC desc = {};
			desc.NumDescriptors = 2;//バックバッファビュー２つ
			desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;//RenderTargetView
			desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;//シェーダからアクセスしないのでNONEでOK
			Hr = Device->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&BackBufViewHeap));
			assert(SUCCEEDED(Hr));
		}
		//バックバッファ「ビュー」を「ディスクリプタヒープ」につくる
		{
			D3D12_CPU_DESCRIPTOR_HANDLE hBbvHeap
				= BackBufViewHeap->GetCPUDescriptorHandleForHeapStart();

			BackBufViewHeapSize
				= Device->GetDescriptorHandleIncrementSize(
					D3D12_DESCRIPTOR_HEAP_TYPE_RTV);

			for (UINT idx = 0; idx < 2; idx++) {
				//バックバッファを取り出す
				Hr = SwapChain->GetBuffer(idx, IID_PPV_ARGS(&BackBufs[idx]));
				assert(SUCCEEDED(Hr));
				//バックバッファのビューをヒープにつくる
				hBbvHeap.ptr += idx * BackBufViewHeapSize;
				Device->CreateRenderTargetView(BackBufs[idx], nullptr, hBbvHeap);
			}
		}

		//頂点バッファ、位置をつくる
		{
			//位置の生データ
			float positions[] = {
				-0.5f, -0.5f, 0.0f,//左下
				-0.5f, 0.5f, 0.0f,//左上
				0.5f, -0.5f, 0.0f,//右下
				0.5f, 0.5f, 0.0f,//右上
			};

			//位置のバッファをつくる
			D3D12_HEAP_PROPERTIES prop
				= CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
			D3D12_RESOURCE_DESC desc
				= CD3DX12_RESOURCE_DESC::Buffer(sizeof(positions));
			//D3D12_HEAP_PROPERTIES prop = {};
			//prop.Type = D3D12_HEAP_TYPE_UPLOAD;
			//prop.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
			//prop.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;
			//prop.CreationNodeMask = 1;
			//prop.VisibleNodeMask = 1;
			//D3D12_RESOURCE_DESC desc = {};
			//desc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
			//desc.Alignment = 0;
			//desc.Width = sizeof(positions);
			//desc.Height = 1;
			//desc.DepthOrArraySize = 1;
			//desc.MipLevels = 1;
			//desc.Format = DXGI_FORMAT_UNKNOWN;
			//desc.SampleDesc.Count = 1;
			//desc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
			//desc.Flags = D3D12_RESOURCE_FLAG_NONE;
			Hr = Device->CreateCommittedResource(
				&prop,
				D3D12_HEAP_FLAG_NONE,
				&desc,
				D3D12_RESOURCE_STATE_GENERIC_READ,
				nullptr,
				IID_PPV_ARGS(&PositionBuf));
			assert(SUCCEEDED(Hr));

			//位置バッファに生データをコピー
			UINT8* mappedBuf;
			Hr = PositionBuf->Map(0, nullptr, reinterpret_cast<void**>(&mappedBuf));
			assert(SUCCEEDED(Hr));
			memcpy(mappedBuf, positions, sizeof(positions));
			PositionBuf->Unmap(0, nullptr);

			//位置バッファのビューを初期化しておく。（ディスクリプタヒープに作らなくてよい）
			PositionBufView.BufferLocation = PositionBuf->GetGPUVirtualAddress();
			PositionBufView.SizeInBytes = sizeof(positions);
			PositionBufView.StrideInBytes = sizeof(float) * 3;
		}
		//頂点バッファ、テクスチャ座標をつくる
		{
			//テクスチャ座標の生データ。 Nを一筆書きするような順番で用意する。
			float texcoords[] = {
				0.0f,1.0f,
				0.0f,0.0f,
				1.0f,1.0f,
				1.0f,0.0f,
			};

			//テクスチャ座標バッファをつくる
			D3D12_HEAP_PROPERTIES prop
				= CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
			D3D12_RESOURCE_DESC desc
				= CD3DX12_RESOURCE_DESC::Buffer(sizeof(texcoords));
			//D3D12_HEAP_PROPERTIES prop = {};
			//prop.Type = D3D12_HEAP_TYPE_UPLOAD;
			//prop.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
			//prop.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;
			//prop.CreationNodeMask = 1;
			//prop.VisibleNodeMask = 1;
			//D3D12_RESOURCE_DESC desc = {};
			//desc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
			//desc.Alignment = 0;
			//desc.Width = sizeof(texcoords);
			//desc.Height = 1;
			//desc.DepthOrArraySize = 1;
			//desc.MipLevels = 1;
			//desc.Format = DXGI_FORMAT_UNKNOWN;
			//desc.SampleDesc.Count = 1;
			//desc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
			//desc.Flags = D3D12_RESOURCE_FLAG_NONE;
			Hr = Device->CreateCommittedResource(
				&prop,
				D3D12_HEAP_FLAG_NONE,
				&desc,
				D3D12_RESOURCE_STATE_GENERIC_READ,
				nullptr,
				IID_PPV_ARGS(&TexcoordBuf));
			assert(SUCCEEDED(Hr));

			//テクスチャ座標バッファに生データをコピー
			UINT8* mappedBuf;
			Hr = TexcoordBuf->Map(0, nullptr, reinterpret_cast<void**>(&mappedBuf));
			assert(SUCCEEDED(Hr));
			memcpy(mappedBuf, texcoords, sizeof(texcoords));
			TexcoordBuf->Unmap(0, nullptr);

			//テクスチャ座標バッファのビューを初期化しておく。（ディスクリプタヒープに作らなくてよい）
			TexcoordBufView.BufferLocation = TexcoordBuf->GetGPUVirtualAddress();
			TexcoordBufView.SizeInBytes = sizeof(texcoords);
			TexcoordBufView.StrideInBytes = sizeof(float) * 2;
		}
		//頂点インデックスバッファをつくる
		{
			unsigned short indices[] = {
				0,1,2,
				2,1,3
			};

			//インデックスバッファをつくる
			D3D12_HEAP_PROPERTIES prop = {};
			prop.Type = D3D12_HEAP_TYPE_UPLOAD;
			prop.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
			prop.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;
			prop.CreationNodeMask = 1;
			prop.VisibleNodeMask = 1;
			D3D12_RESOURCE_DESC desc = {};
			desc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
			desc.Alignment = 0;
			desc.Width = sizeof(indices);
			desc.Height = 1;
			desc.DepthOrArraySize = 1;
			desc.MipLevels = 1;
			desc.Format = DXGI_FORMAT_UNKNOWN;
			desc.SampleDesc.Count = 1;
			desc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
			desc.Flags = D3D12_RESOURCE_FLAG_NONE;
			Hr = Device->CreateCommittedResource(
				&prop,
				D3D12_HEAP_FLAG_NONE,
				&desc,
				D3D12_RESOURCE_STATE_GENERIC_READ,
				nullptr,
				IID_PPV_ARGS(&IndexBuf));
			assert(SUCCEEDED(Hr));

			//作ったバッファにデータをコピー
			UINT8* mappedBuf = nullptr;
			Hr = IndexBuf->Map(0, nullptr, (void**)&mappedBuf);
			assert(SUCCEEDED(Hr));
			memcpy(mappedBuf, indices, sizeof(indices));
			IndexBuf->Unmap(0, nullptr);

			//インデックスバッファビューをつくる
			IndexBufView.BufferLocation = IndexBuf->GetGPUVirtualAddress();
			IndexBufView.Format = DXGI_FORMAT_R16_UINT;
			IndexBufView.SizeInBytes = sizeof(indices);
		}

		//コンスタントバッファ_aとテクスチャバッファ_a ⇒ ディスクリプタヒープ_a
		{
			//コンスタントバッファ０_aをつくる
			{
				D3D12_HEAP_PROPERTIES prop
					= CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
				D3D12_RESOURCE_DESC desc
					= CD3DX12_RESOURCE_DESC::Buffer(256);
				//D3D12_HEAP_PROPERTIES prop = {};
				//prop.Type = D3D12_HEAP_TYPE_UPLOAD;
				//prop.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
				//prop.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;
				//prop.CreationNodeMask = 1;
				//prop.VisibleNodeMask = 1;
				//D3D12_RESOURCE_DESC desc = {};
				//desc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
				//desc.Alignment = 0;
				//desc.Width = 256;
				//desc.Height = 1;
				//desc.DepthOrArraySize = 1;
				//desc.MipLevels = 1;
				//desc.Format = DXGI_FORMAT_UNKNOWN;
				//desc.SampleDesc = { 1, 0 };
				//desc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
				//desc.Flags = D3D12_RESOURCE_FLAG_NONE;
				Hr = Device->CreateCommittedResource(
					&prop,
					D3D12_HEAP_FLAG_NONE,
					&desc,
					D3D12_RESOURCE_STATE_GENERIC_READ,
					nullptr,
					IID_PPV_ARGS(&ConstBuf0_a)
				);
				assert(SUCCEEDED(Hr));

				//マップしておいて、メインループ中で更新する。
				Hr = ConstBuf0_a->Map(0, nullptr, (void**)&MapConstBuf0_a);
				assert(SUCCEEDED(Hr));
			}
			//コンスタントバッファ１_aをつくる
			{
				D3D12_HEAP_PROPERTIES prop
					= CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
				D3D12_RESOURCE_DESC desc
					= CD3DX12_RESOURCE_DESC::Buffer(256);
				//D3D12_HEAP_PROPERTIES prop = {};
				//prop.Type = D3D12_HEAP_TYPE_UPLOAD;
				//prop.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
				//prop.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;
				//prop.CreationNodeMask = 1;
				//prop.VisibleNodeMask = 1;
				//D3D12_RESOURCE_DESC desc = {};
				//desc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
				//desc.Alignment = 0;
				//desc.Width = 256;
				//desc.Height = 1;
				//desc.DepthOrArraySize = 1;
				//desc.MipLevels = 1;
				//desc.Format = DXGI_FORMAT_UNKNOWN;
				//desc.SampleDesc = { 1, 0 };
				//desc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
				//desc.Flags = D3D12_RESOURCE_FLAG_NONE;
				Hr = Device->CreateCommittedResource(
					&prop,
					D3D12_HEAP_FLAG_NONE,
					&desc,
					D3D12_RESOURCE_STATE_GENERIC_READ,
					nullptr,
					IID_PPV_ARGS(&ConstBuf1_a)
				);
				assert(SUCCEEDED(Hr));

				//マップしておいて、メインループ中で更新する。
				Hr = ConstBuf1_a->Map(0, nullptr, (void**)&MapConstBuf1_a);
				assert(SUCCEEDED(Hr));
			}
			//テクスチャバッファ_aをつくる(簡易バージョン)
			{
				//ファイルを読み込み、画像データを取り出す
				unsigned char* pixels;
				int width, height, bpp;
				//  最後の引数でピクセルあたりのバイト数を強制できる
				pixels = stbi_load("assets\\penguin1.png", &width, &height, &bpp, 4);
				assert(pixels != nullptr);

				//テクスチャバッファ
				D3D12_HEAP_PROPERTIES prop = {};
				prop.Type = D3D12_HEAP_TYPE_CUSTOM;//特殊な設定なのでdefaultでもuploadでもなく
				prop.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_WRITE_BACK;//ライトバックで
				prop.MemoryPoolPreference = D3D12_MEMORY_POOL_L0;//転送がL0つまりCPU側から直で
				prop.CreationNodeMask = 0;//単一アダプタのため0
				prop.VisibleNodeMask = 0;//単一アダプタのため0
				D3D12_RESOURCE_DESC desc = {};
				desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;//RGBAフォーマット
				desc.Width = width;
				desc.Height = height;
				desc.DepthOrArraySize = 1;
				desc.SampleDesc.Count = 1;//通常テクスチャなのでアンチェリしない
				desc.SampleDesc.Quality = 0;//通常テクスチャなのでアンチェリしない
				desc.MipLevels = 1;
				desc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;//2Dテクスチャ用
				desc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;//レイアウトについては決定しない
				desc.Flags = D3D12_RESOURCE_FLAG_NONE;//とくにフラグなし
				Hr = Device->CreateCommittedResource(
					&prop,
					D3D12_HEAP_FLAG_NONE,//特に指定なし
					&desc,
					D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE,//テクスチャ用(ピクセルシェーダから見る用)
					nullptr,
					IID_PPV_ARGS(&TextureBuf_a)
				);
				assert(SUCCEEDED(Hr));

				//テクスチャバッファに生データをコピー
				Hr = TextureBuf_a->WriteToSubresource(0,
					nullptr, // 全領域へコピー 
					pixels, // 元データアドレス 
					width * bpp, // 1ラインサイズ 
					width * height * bpp // 全サイズ
				);

				//生データ開放
				stbi_image_free(pixels);
			}
			//ディスクリプタヒープ_a、そしてビューをつくる
			{
				//コンスタントバッファ０と１の「ビュー」の入れ物である「ディスクリプタヒープ」をつくる
				{
					D3D12_DESCRIPTOR_HEAP_DESC desc = {};
					desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
					desc.NumDescriptors = 3;//コンスタントバッファ２つとテクスチャバッファ１つ
					desc.NodeMask = 0;
					desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
					Hr = Device->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&CbvTbvHeap_a));
					assert(SUCCEEDED(Hr));
				}

				auto hCbvTbvHeap_a = CbvTbvHeap_a->GetCPUDescriptorHandleForHeapStart();
				auto heapSize = Device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

				//コンスタントバッファ０の「ビュー」を「ディスクリプタヒープ」につくる
				{
					D3D12_CONSTANT_BUFFER_VIEW_DESC desc = {};
					desc.BufferLocation = ConstBuf0_a->GetGPUVirtualAddress();
					desc.SizeInBytes = static_cast<UINT>(ConstBuf0_a->GetDesc().Width);
					Device->CreateConstantBufferView(&desc, hCbvTbvHeap_a);
				}

				hCbvTbvHeap_a.ptr += heapSize;

				//コンスタントバッファ１の「ビュー」を「ディスクリプタヒープ」につくる
				{
					D3D12_CONSTANT_BUFFER_VIEW_DESC desc = {};
					desc.BufferLocation = ConstBuf1_a->GetGPUVirtualAddress();
					desc.SizeInBytes = static_cast<UINT>(ConstBuf1_a->GetDesc().Width);
					Device->CreateConstantBufferView(&desc, hCbvTbvHeap_a);
				}

				hCbvTbvHeap_a.ptr += heapSize;
				
				//ディスクリプタヒープにテクスチャバッファのビューをつくる
				{
					D3D12_SHADER_RESOURCE_VIEW_DESC desc = {};
					desc.Format = TextureBuf_a->GetDesc().Format;
					desc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
					desc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;//2Dテクスチャ
					desc.Texture2D.MipLevels = 1;//ミップマップは使用しないので1
					Device->CreateShaderResourceView(TextureBuf_a, &desc, hCbvTbvHeap_a);
				}
			}
		}{}
		//コンスタントバッファ_bとテクスチャバッファ_b ⇒ ディスクリプタヒープ_b
		{
			//コンスタントバッファ０_bをつくる
			{
				auto prop = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
				auto desc = CD3DX12_RESOURCE_DESC::Buffer(256);
				Hr = Device->CreateCommittedResource(
					&prop,
					D3D12_HEAP_FLAG_NONE,
					&desc,
					D3D12_RESOURCE_STATE_GENERIC_READ,
					nullptr,
					IID_PPV_ARGS(&ConstBuf0_b));
				assert(SUCCEEDED(Hr));

				//マップしておいて、メインループ中で更新する。
				Hr = ConstBuf0_b->Map(0, nullptr, (void**)&MapConstBuf0_b);
				assert(SUCCEEDED(Hr));
			}
			//コンスタントバッファ１_bをつくる
			{
				auto prop = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
				auto desc= CD3DX12_RESOURCE_DESC::Buffer(256);
				Hr = Device->CreateCommittedResource(
					&prop,
					D3D12_HEAP_FLAG_NONE,
					&desc,
					D3D12_RESOURCE_STATE_GENERIC_READ,
					nullptr,
					IID_PPV_ARGS(&ConstBuf1_b));
				assert(SUCCEEDED(Hr));

				//マップしておいて、メインループ中で更新する。
				Hr = ConstBuf1_b->Map(0, nullptr, (void**)&MapConstBuf1_b);
				assert(SUCCEEDED(Hr));
			}
			//テクスチャバッファ_bをつくる(Microsoft推奨バージョン)
			{
				//ファイルを読み込み、画像データを取り出す
				unsigned char* pixels;
				int width, height, bytePerPixel;
				//                       最後の引数でピクセルあたりのバイト数を強制できる↓
				pixels = stbi_load("assets\\penguin2.png", &width, &height, &bytePerPixel, 4);
				assert(pixels != nullptr);

				//テクスチャバッファ_bを作る
				{
					auto prop = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT);
					D3D12_RESOURCE_DESC desc = {};
					desc.MipLevels = 1;
					desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
					desc.Width = width;
					desc.Height = height;
					desc.Flags = D3D12_RESOURCE_FLAG_NONE;
					desc.DepthOrArraySize = 1;
					desc.SampleDesc.Count = 1;
					desc.SampleDesc.Quality = 0;
					desc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
					Hr = Device->CreateCommittedResource(
						&prop,
						D3D12_HEAP_FLAG_NONE,
						&desc,
						D3D12_RESOURCE_STATE_COPY_DEST,
						nullptr,
						IID_PPV_ARGS(&TextureBuf_b));
					assert(SUCCEEDED(Hr));
				}

				//アップロード用中間バッファをつくる
				ID3D12Resource* uploadBuf;
				const UINT64 uploadBufSize
					= GetRequiredIntermediateSize(TextureBuf_b, 0, 1);
				{
					auto prop = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
					auto desc = CD3DX12_RESOURCE_DESC::Buffer(uploadBufSize);
					Hr = Device->CreateCommittedResource(
						&prop,
						D3D12_HEAP_FLAG_NONE,
						&desc,
						D3D12_RESOURCE_STATE_GENERIC_READ,
						nullptr,
						IID_PPV_ARGS(&uploadBuf));
					assert(SUCCEEDED(Hr));
				}

				//データを中間バッファにコピーし、その後、
				//中間バッファからテクスチャバッファへのコピーをスケジュールする
				D3D12_SUBRESOURCE_DATA textureData = {};
				textureData.pData = pixels;
				textureData.RowPitch = width * 4;
				textureData.SlicePitch = width * height * 4;
				UpdateSubresources(CommandList, 
					TextureBuf_b, uploadBuf, 0, 0, 1, &textureData);

				//バリア
				auto barrier = CD3DX12_RESOURCE_BARRIER::Transition(
						TextureBuf_b,
						D3D12_RESOURCE_STATE_COPY_DEST,
						D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);
				CommandList->ResourceBarrier(1, &barrier);
				//アンロード
				CommandList->DiscardResource(uploadBuf, nullptr);
				//コマンドリストを閉じて
				CommandList->Close();
				//実行
				ID3D12CommandList* commandLists[] = { CommandList };
				CommandQueue->ExecuteCommandLists(_countof(commandLists), commandLists);
				//リソースがGPUに転送されるまで待機する
				WaitDrawDone();
				//コマンドアロケータをリセット
				HRESULT Hr = CommandAllocator->Reset();
				assert(SUCCEEDED(Hr));
				//コマンドリストをリセット
				Hr = CommandList->Reset(CommandAllocator, nullptr);
				assert(SUCCEEDED(Hr));

				//開放
				uploadBuf->Release();
				stbi_image_free(pixels);
			}
			//ディスクリプタヒープ_bをつくり、そこにビューをつくる
			{
				//「ビュー」の入れ物である「ディスクリプタヒープ_b」をつくる
				{
					D3D12_DESCRIPTOR_HEAP_DESC desc = {};
					desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
					desc.NumDescriptors = 3;//コンスタントバッファ２つとテクスチャバッファ１つ
					desc.NodeMask = 0;
					desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
					Hr = Device->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&CbvTbvHeap_b));
					assert(SUCCEEDED(Hr));
				}

				auto hCbvTbvHeap_b = CbvTbvHeap_b->GetCPUDescriptorHandleForHeapStart();
				auto heapSize = Device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

				//コンスタントバッファ０_bの「ビュー」を「ディスクリプタヒープ_b」につくる
				{
					D3D12_CONSTANT_BUFFER_VIEW_DESC desc = {};
					desc.BufferLocation = ConstBuf0_b->GetGPUVirtualAddress();
					desc.SizeInBytes = static_cast<UINT>(ConstBuf0_b->GetDesc().Width);
					Device->CreateConstantBufferView(&desc, hCbvTbvHeap_b);
				}

				hCbvTbvHeap_b.ptr += heapSize;

				//コンスタントバッファ１_bの「ビュー」を「ディスクリプタヒープ_b」につくる
				{
					D3D12_CONSTANT_BUFFER_VIEW_DESC desc = {};
					desc.BufferLocation = ConstBuf1_b->GetGPUVirtualAddress();
					desc.SizeInBytes = static_cast<UINT>(ConstBuf1_b->GetDesc().Width);
					Device->CreateConstantBufferView(&desc, hCbvTbvHeap_b);
				}

				hCbvTbvHeap_b.ptr += heapSize;

				//テクスチャバッファ_bの「ビュー」を「ディスクリプタヒープ_b」につくる
				{
					D3D12_SHADER_RESOURCE_VIEW_DESC desc = {};
					desc.Format = TextureBuf_b->GetDesc().Format;
					desc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
					desc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;//2Dテクスチャ
					desc.Texture2D.MipLevels = 1;//ミップマップは使用しないので1
					Device->CreateShaderResourceView(TextureBuf_b, &desc, hCbvTbvHeap_b);
				}
			}
		}
	}{}
	//パイプライン
	{
		//ルートシグネチャ
		{
			//ディスクリプタレンジ。ディスクリプタヒープとシェーダを紐づけるもの。
			D3D12_DESCRIPTOR_RANGE range[3] = {};
			UINT b0 = 0;
			range[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_CBV;
			range[0].BaseShaderRegister = b0;
			range[0].NumDescriptors = 1;
			range[0].RegisterSpace = 0;
			range[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;
			UINT b1 = 1;
			range[1].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_CBV;
			range[1].BaseShaderRegister = b1;
			range[1].NumDescriptors = 1;
			range[1].RegisterSpace = 0;
			range[1].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;
			UINT t0 = 0;
			range[2].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
			range[2].BaseShaderRegister = t0;
			range[2].NumDescriptors = 1;
			range[2].RegisterSpace = 0;
			range[2].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;

			//ルートパラメタをディスクリプタテーブルとして使用
			D3D12_ROOT_PARAMETER rootParam[1] = {};
			rootParam[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
			rootParam[0].DescriptorTable.pDescriptorRanges = range;
			rootParam[0].DescriptorTable.NumDescriptorRanges = _countof(range);
			rootParam[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;

			//サンプラの記述。このサンプラがシェーダーの s0 にセットされる
			D3D12_STATIC_SAMPLER_DESC samplerDesc[1] = {};
			samplerDesc[0].Filter = D3D12_FILTER_MIN_MAG_MIP_POINT;//補間しない(ニアレストネイバー)
			samplerDesc[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;//横繰り返し
			samplerDesc[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;//縦繰り返し
			samplerDesc[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;//奥行繰り返し
			samplerDesc[0].BorderColor = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;//ボーダーの時は黒
			samplerDesc[0].MaxLOD = D3D12_FLOAT32_MAX;//ミップマップ最大値
			samplerDesc[0].MinLOD = 0.0f;//ミップマップ最小値
			samplerDesc[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;//オーバーサンプリングの際リサンプリングしない？
			samplerDesc[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//ピクセルシェーダからのみ可視

			//ルートシグニチャの記述。上のrootParamとsamplerDescを１つにまとめる。
			D3D12_ROOT_SIGNATURE_DESC desc = {};
			desc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
			desc.pParameters = rootParam;//ルートパラメータの先頭アドレス
			desc.NumParameters = _countof(rootParam);//ルートパラメータ数
			desc.pStaticSamplers = samplerDesc;//サンプラーの先頭アドレス
			desc.NumStaticSamplers = _countof(samplerDesc);//サンプラー数

			//ルートシグネチャをシリアライズ⇒blob(塊)をつくる。
			ID3DBlob* blob;
			Hr = D3D12SerializeRootSignature(&desc, D3D_ROOT_SIGNATURE_VERSION_1, &blob, nullptr);
			assert(SUCCEEDED(Hr));

			//ルートシグネチャをつくる
			Hr = Device->CreateRootSignature(0, blob->GetBufferPointer(), blob->GetBufferSize(),
				IID_PPV_ARGS(&RootSignature));
			assert(SUCCEEDED(Hr));
			blob->Release();
		}

		//シェーダ読み込み
		BIN_FILE12 vs("assets\\VertexShader.cso");
		assert(vs.succeeded());
		BIN_FILE12 ps("assets\\PixelShader.cso");
		assert(ps.succeeded());


		//以下、各種記述

		UINT slot0 = 0, slot1 = 1;
		D3D12_INPUT_ELEMENT_DESC elementDescs[] = {
			{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, slot0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
			{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, slot1, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		};

		D3D12_RASTERIZER_DESC rasterDesc = {};
		rasterDesc.FrontCounterClockwise = false;
		rasterDesc.CullMode = D3D12_CULL_MODE_NONE;
		rasterDesc.FillMode = D3D12_FILL_MODE_SOLID;
		rasterDesc.DepthBias = D3D12_DEFAULT_DEPTH_BIAS;
		rasterDesc.DepthBiasClamp = D3D12_DEFAULT_DEPTH_BIAS_CLAMP;
		rasterDesc.SlopeScaledDepthBias = D3D12_DEFAULT_SLOPE_SCALED_DEPTH_BIAS;
		rasterDesc.DepthClipEnable = true;
		rasterDesc.MultisampleEnable = false;
		rasterDesc.AntialiasedLineEnable = false;
		rasterDesc.ForcedSampleCount = 0;
		rasterDesc.ConservativeRaster = D3D12_CONSERVATIVE_RASTERIZATION_MODE_OFF;

		D3D12_BLEND_DESC blendDesc = {};
		blendDesc.AlphaToCoverageEnable = false;
		blendDesc.IndependentBlendEnable = false;
		blendDesc.RenderTarget[0].BlendEnable = true;
		blendDesc.RenderTarget[0].LogicOpEnable = false;
		blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;
		blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_ALPHA;
		blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		blendDesc.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ONE;
		blendDesc.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ZERO;
		blendDesc.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;
		blendDesc.RenderTarget[0].LogicOp = D3D12_LOGIC_OP_NOOP;
		blendDesc.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;

		D3D12_DEPTH_STENCIL_DESC depthStencilDesc = {};
		depthStencilDesc.DepthEnable = false;
		depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;//全て書き込み
		depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS;//小さい方を採用
		depthStencilDesc.StencilEnable = false;//ステンシルバッファは使わない


		//ここまでの記述をまとめてパイプラインステートオブジェクトをつくる
		D3D12_GRAPHICS_PIPELINE_STATE_DESC pipelineDesc = {};
		pipelineDesc.pRootSignature = RootSignature;
		pipelineDesc.VS = { vs.code(), vs.size() };
		pipelineDesc.PS = { ps.code(), ps.size() };
		pipelineDesc.InputLayout = { elementDescs, _countof(elementDescs) };
		pipelineDesc.RasterizerState = rasterDesc;
		pipelineDesc.BlendState = blendDesc;
		pipelineDesc.DepthStencilState = depthStencilDesc;
		pipelineDesc.DSVFormat = DXGI_FORMAT_D32_FLOAT;
		pipelineDesc.SampleMask = UINT_MAX;
		pipelineDesc.SampleDesc.Count = 1;
		pipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
		pipelineDesc.NumRenderTargets = 1;
		pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
		Hr = Device->CreateGraphicsPipelineState(
			&pipelineDesc,
			IID_PPV_ARGS(&PipelineState)
		);
		assert(SUCCEEDED(Hr));

		//出力領域を設定
		Viewport.TopLeftX = 0.0f;
		Viewport.TopLeftY = 0.0f;
		Viewport.Width = ClientWidth;
		Viewport.Height = ClientHeight;
		Viewport.MinDepth = 0.0f;
		Viewport.MaxDepth = 1.0f;

		//切り取り矩形を設定
		ScissorRect.left = 0;
		ScissorRect.top = 0;
		ScissorRect.right = ClientWidth;
		ScissorRect.bottom = ClientHeight;
	}

	//メインループ
	while (true)
	{
		//ウィンドウメッセージの取得、送出
		{
			MSG msg = { 0 };
			if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
				if (msg.message == WM_QUIT)
					break;
				TranslateMessage(&msg);
				DispatchMessage(&msg);
				continue;
			}
		}
		//バックバッファをクリア
		{
			//現在のバックバッファのインデックスを取得。このプログラムの場合0 or 1になる。
			BackBufIdx = SwapChain->GetCurrentBackBufferIndex();

			//バックバッファが描画ターゲットとして使用できるようになるまで待つ
			auto barrier = CD3DX12_RESOURCE_BARRIER::Transition(
					BackBufs[BackBufIdx],
					D3D12_RESOURCE_STATE_PRESENT,
					D3D12_RESOURCE_STATE_RENDER_TARGET);
			//D3D12_RESOURCE_BARRIER barrier;
			//barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;//リソースの状態遷移に対してバリアを設置
			//barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
			//barrier.Transition.pResource = BackBufs[BackBufIdx];//リソースは描画ターゲット
			//barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;//遷移前はPresent
			//barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;//遷移後は描画ターゲット
			//barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
			CommandList->ResourceBarrier(1, &barrier);

			//バックバッファのディスクリプタハンドルを用意する
			auto hBbvHeap = BackBufViewHeap->GetCPUDescriptorHandleForHeapStart();
			hBbvHeap.ptr += BackBufIdx * BackBufViewHeapSize;
			//バックバッファを描画ターゲットとして設定する
			CommandList->OMSetRenderTargets(1, &hBbvHeap, false, nullptr);
			//描画ターゲットをクリアする
			static float radian = 0.0f;
			float r = cos(radian) * 0.5f + 0.5f;
			float g = 0.25f;
			float b = 0.5f;
			const float clearColor[] = { r, g, b, 1.0f };
			radian += 0.01f;
			CommandList->ClearRenderTargetView(hBbvHeap, clearColor, 0, nullptr);
		}
		//バックバッファに描画
		{
			//パイプラインステートをセット
			CommandList->SetPipelineState(PipelineState);
			//ビューポートとシザー矩形をセット
			CommandList->RSSetViewports(1, &Viewport);
			CommandList->RSSetScissorRects(1, &ScissorRect);
			//ルートシグニチャ
			CommandList->SetGraphicsRootSignature(RootSignature);

			//頂点をセット
			D3D12_VERTEX_BUFFER_VIEW bufViews[] = {
				PositionBufView,
				TexcoordBufView,
			};
			CommandList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
			CommandList->IASetVertexBuffers(0, _countof(bufViews), bufViews);
			CommandList->IASetIndexBuffer(&IndexBufView);

			//　回転用ラジアン
			static float radian = 0;
			radian += 0.01f;
			//モデル＿ａの描画
			{
				//コンスタントバッファ０＿ａ更新
				//　ワールドマトリックス
				MapConstBuf0_a->world =
					XMMatrixRotationY(radian)
					* XMMatrixTranslation(-0.5f, 0.0f, 0.0f);
				//　ビューマトリックス
				XMFLOAT3 eye(sin(radian*0.f)*2, 0.0f, -cos(radian*0.f) * 2), 
					target(0, 0, 0), up(0, 1, 0);
				MapConstBuf0_a->view = XMMatrixLookAtLH(
					XMLoadFloat3(&eye), XMLoadFloat3(&target), XMLoadFloat3(&up));
				//　プロジェクションマトリックス
				MapConstBuf0_a->proj = XMMatrixPerspectiveFovLH(XM_PIDIV4, Aspect, 1.0f, 10.0f);

				//コンスタントバッファ１＿ａ更新
				float col = cos(radian) * 0.5f + 0.5f;
				MapConstBuf1_a->diffuse = { col,1.0f,0.0f,1.0f };

				//コマンドリストにディスクリプタヒープ＿ａを紐づける
				CommandList->SetDescriptorHeaps(1, &CbvTbvHeap_a);
				//ディスクリプタテーブルにディスクリプタヒープ＿ａをセット
				auto hCbvTbvHeap_a = CbvTbvHeap_a->GetGPUDescriptorHandleForHeapStart();
				CommandList->SetGraphicsRootDescriptorTable(0, hCbvTbvHeap_a);

				//描画
				CommandList->DrawIndexedInstanced(6, 1, 0, 0, 0);
			}
			//モデル＿ｂの描画
			{
				//コンスタントバッファ０＿ｂ更新
				//　ワールドマトリックス
				MapConstBuf0_b->world =
					XMMatrixRotationY(radian)
					* XMMatrixTranslation(0.5f, 0.0f, 0.0f);
				//　ビューマトリックス
				MapConstBuf0_b->view = MapConstBuf0_a->view;
				//　プロジェクションマトリックス
				MapConstBuf0_b->proj = MapConstBuf0_a->proj;

				//コンスタントバッファ１＿ｂ更新
				float col = cos(radian) * 0.5f + 0.5f;
				MapConstBuf1_b->diffuse = { col,0.0f,1.0f,1.0f };

				//コマンドリストにディスクリプタヒープ＿ｂを紐づける
				CommandList->SetDescriptorHeaps(1, &CbvTbvHeap_b);
				//ディスクリプタテーブルにディスクリプタヒープ＿ｂをセット
				auto hCbvTbvHeap_b = CbvTbvHeap_b->GetGPUDescriptorHandleForHeapStart();
				CommandList->SetGraphicsRootDescriptorTable(0, hCbvTbvHeap_b);

				//描画
				CommandList->DrawIndexedInstanced(6, 1, 0, 0, 0);
			}
		}
		//バックバッファを表示
		{
			//バックバッファの描画完了を待つためのバリアを設置
			auto barrier = CD3DX12_RESOURCE_BARRIER::Transition(
				BackBufs[BackBufIdx],
				D3D12_RESOURCE_STATE_RENDER_TARGET,
				D3D12_RESOURCE_STATE_PRESENT);
			//D3D12_RESOURCE_BARRIER barrier;
			//barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;//バリアをリソースの状態遷移に対して設置
			//barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
			//barrier.Transition.pResource = BackBufs[BackBufIdx];//リソースは描画ターゲット
			//barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;//遷移前は描画ターゲット
			//barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT;//遷移後はPresent
			//barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
			CommandList->ResourceBarrier(1, &barrier);

			//コマンドリストをクローズする
			CommandList->Close();
			//コマンドリストを実行する
			ID3D12CommandList* commandLists[] = { CommandList };
			CommandQueue->ExecuteCommandLists(_countof(commandLists), commandLists);
			//描画完了を待つ
			WaitDrawDone();
			
			//コマンドアロケータをリセット
			Hr = CommandAllocator->Reset();
			assert(SUCCEEDED(Hr));
			//コマンドリストをリセット
			Hr = CommandList->Reset(CommandAllocator, nullptr);
			assert(SUCCEEDED(Hr));

			//バッファを表示
			SwapChain->Present(1, 0);
		}
	}{}

	//解放
	{
		WaitDrawDone();

		PipelineState->Release();
		RootSignature->Release();

		CbvTbvHeap_b->Release();
		TextureBuf_b->Release();
		ConstBuf1_b->Unmap(0, nullptr);
		ConstBuf1_b->Release();
		ConstBuf0_b->Unmap(0, nullptr);
		ConstBuf0_b->Release();

		CbvTbvHeap_a->Release();
		TextureBuf_a->Release();
		ConstBuf1_a->Unmap(0, nullptr);
		ConstBuf1_a->Release();
		ConstBuf0_a->Unmap(0, nullptr);
		ConstBuf0_a->Release();

		IndexBuf->Release();
		TexcoordBuf->Release();
		PositionBuf->Release();

		BackBufViewHeap->Release();
		BackBufs[0]->Release();
		BackBufs[1]->Release();
		SwapChain->Release();

		CloseHandle(FenceEvent);
		Fence->Release();

		CommandQueue->Release();
		CommandList->Release();
		CommandAllocator->Release();

		Device->Release();
	}
}

// 描画完了を待つ
void WaitDrawDone()
{
	//現在のFence値がコマンド終了後にFenceに書き込まれるようにする
	UINT64 fvalue = FenceValue;
	CommandQueue->Signal(Fence, fvalue);
	FenceValue++;

	//まだコマンドキューが終了していないことを確認する
	if (Fence->GetCompletedValue() < fvalue)
	{
		//このFenceにおいて、fvalue の値になったらイベントを発生させる
		Fence->SetEventOnCompletion(fvalue, FenceEvent);
		//イベントが発生するまで待つ
		WaitForSingleObject(FenceEvent, INFINITE);
	}
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg) {
	case WM_DESTROY:
		PostQuitMessage(0);
		return 0;
	default:
		return DefWindowProc(hwnd, msg, wp, lp);
	}
}
